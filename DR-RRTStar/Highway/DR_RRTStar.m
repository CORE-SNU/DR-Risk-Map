% Each node in the tree has the following attributes:
%     coord              - Robot's state
%     cost               - Total cost including the risk term
%     parent             - The index of the parent node (it is set to 0 for the root node)
%     used_controls      - A list of all control inputs that have already been applied to the node
%     depth              - Depth of the node starting from the current root
%     risk               - DR-CVaR risk of the node
%     safe               - Checks whether the risk constraint is satisfied with a tolerance level delta
%     children           - List of all children node indices
%     index              - Index of the node
%     input              - The control input applied to the current node

clear all
close all
global pos_mu pos_var controller r2 t L_r minAngle maxAngle minVel maxVel Ts w_risk K new_pl poscont ucost root

Set_Params % Set parameters

load('obs_traj.mat') % Load obstacle trajectories (Can be generated by running obstacle_traj_gen.m)
load('q_rand.mat') % Load the dataset of random points in the configuration space to ease the computational burden (Can be generated by running gen_q_rand.m) 
load('dynamics.mat') % Load pretrained NN weights for dynamics

% Create a directory for saving simulation results 
try
    [status, msg, msgID] = mkdir('Simulations/');
end

Initialize_tree % Set the start and goal nodes of the tree
Construct_Figure % Initialize figure for rendering
SDP_solver % Generate and SDP solver for the DR-CVaR upper bound

t = 1; % Initialize time
i = 0;
terminate = 0;
solve_time = tic; % Start counting computation time

while ~terminate
    Observe_and_Update; % Lines 5-9
    GP_pred_NN; % Lines 10-16
    Construct_Safe_Tree; % Lines 17-22
    Tree_Expansion % Lines 23-24
    Plan_Path % Line 25

    % Save the current tree and best path
    Path{t} = Best;
    Tree{t} = safe_nodes;

    if save_video==true
        frame = getframe(gcf);
        writeVideo(writerObj, frame);
    end

    % Update the robot state
    rob_state(:,t+1)=Best(2).coord;

    % For rendering
    uistack(rob_traj,'top')
    uistack(rob_pl,'top')
    set(rob_obj,'Position',[rob_state(1,t+1)-rob_rad rob_state(2,t+1)-rob_rad 2*rob_rad 2*rob_rad]);
    set(rob_pl,'xdata',Best(2).coord(1));
    set(rob_pl,'ydata',Best(2).coord(2));
    set(rob_traj, 'xdata', rob_state(1,1:t+1));
    set(rob_traj, 'ydata', rob_state(2,1:t+1));
    try
        delete(best_pl)
    end

    % Terminate if the robot is close to the goal
    if sqrt(sum((rob_state(1:2,t+1)-q_goal.coord(1:2)).^2)) <=0.5 || any(sqrt(sum((rob_state(1:2,t+1)-obs_state(1:2,t+1,:)).^2)) <= rob_rad + obs_rad + safe_rad)
        terminate=1;
        if save_video==true
            close(writerObj)
        end
    end
    
    t = t + 1;
end

% Save simulation results
save(['Simulations/sol_',num2str(theta),'.mat'],'Path','Tree','rob_state', 'pos_mu','pos_var');